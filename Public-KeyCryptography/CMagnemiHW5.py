import conversions
import binascii
import euclid_etc
import random


def kthroot(k,N):
    low = 0
    high = N
    while low+1 < high:
        mid = (low+high)/2
        if mid**k >= N:
            high = mid
        else:
            low = mid
    return high


def b64_to_bits(b64text):
    text = conversions.b64_to_hex(b64text)
    bits = int(text, 16)
    return bits


def problem1(ciphertext, modulus):
    c_as_bits = b64_to_bits(ciphertext)
    plaintext = kthroot(3, c_as_bits)
    if plaintext**3 == c_as_bits:
        # return 'perfect cube'
        h = hex(plaintext)
        h = h[2:-1]
        answer = conversions.hex_to_as(h)
        print answer
        return answer
    else:
        print 'not a perfect cube'


def egcd(a, b):
    if a == 0:
        return (b, 0, 1)
    else:
        g, y, x = egcd(b % a, a)
        return (g, x - (b // a) * y, y)


def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


def problem2(ct1, ct2, ct3, mod1, mod2, mod3):
    c1 = 'PBq5gXUhUHA9odbER2Oow3aBRX5VzEPPRCPdcFPZisJSDtoDQtCGiDdcD4q5qNWtA7dMRZxktHzO1kQy1HNmgg6jjUnxuXPIihJgTG4rAQaAFVJrj9THVoaNb+QxovCU61c7N49H+tekr6xyGyGSok6wNnLZtE0GQd8p3zbyIAg='
    c2 = 'a11Wynb/5BbzR2+gfZ5vgyJvlk0VHAUP08F2tvEZKCsS4Q0zaHok9FBf3QSJxn7X+e9+bADoV0aycZpXh/8hchNE5jER156vamjQm/9cmLwVcQeK/IFJOOmvuFEWYwOg3L8r2Jsii6cn/XrStNZ4JypnOhzbyhR5Jd8hsC2pPIo='
    c3 = 'HlPEAzFjvc1ipxHIaig2o6WwpHfsHmIuS07lM0uKmY0VzcxyiOyB8Q0f4yjo8mu5yPYteO5Kiz5W3sk2j/d5ClmU7yUOVRxm5Q8LXymjpkhLK/I+cxO5P3WRjXF6tUiS/7cz+Koox/r1zC0W4BdfCzr3LSjM/khFHyRyxsmW9Ec='
    ciphertext1 = b64_to_bits(ct1)
    ciphertext2 = b64_to_bits(ct2)
    ciphertext3 = b64_to_bits(ct3)
    modulus1 = 116352696909960426025864851693810318405618117771451092066454825684677043175680039111752172705287741166921435658711582887107841565748470707915492808066623281928343866378761016071751094691691153177015920723800541267192488702040046723176890027878282090184778778793686252497241689941158021804171328580092708776333
    modulus2 = 113159069239053057823530426012762733579195323934158077138440185385412667833688850511263203419882218256057634130377557866771685834979020529147973323837633935391154851580497106210797073916815264166772985134768913514820393183935763151959349642321950865577799563213986693573189083682991881468336071564883866833467
    modulus3 = 84645091220488904665996303582605230466879862527671219768265030555132951506114250139685118956675414529710122137796339176130460114790081203074349445462593477716603703644138088562638660083014885373629701703614641595720381677601897924624948376232277832479665238039958287396790532376148968417689500200999461168369
    modproduct = mod1 * mod2 * mod3
    products1 = modproduct / mod1
    products2 = modproduct / mod2
    products3 = modproduct / mod3
    inverse1 = modinv(products1, mod1)
    inverse2 = modinv(products2, mod2)
    inverse3 = modinv(products3, mod3)
    sum1 = ciphertext1 * products1 * inverse1
    sum2 = ciphertext2 * products2 * inverse2
    sum3 = ciphertext3 * products3 * inverse3
    sumtotal = sum1 + sum2 + sum3
    crtoutput = sumtotal % modproduct
    M = kthroot(3, crtoutput)
    h = hex(M)
    h = h[2:-1]
    answer = conversions.hex_to_as(h)
    print answer
    return answer


def problem3(ct, d, modulus):
    # modulus = 118655596447903224963869613053944974689306948978385022351313547236325408711597515968013120482999812623684614237188826586513936280546323473924322265897469916282911780567243884859836121621708694140679468147474220271417145483116948895892297437839699778114403528270801117190611396069302409336194794071895031049811
    # d = 23731119289580644992773922610788994937861389795677004470262709447265081742319503193602624096599962524736922847437765317302787256109264694784864453179493978848181776281125630457673065339633910037899644296946114786385008468034547208885433370715974640426127989454209067113013826578800440508863151210816724921125
    # ct = 'LbJFbZa7eoMEQE8uPICTjzxFqvtM2qLPf6OSNOR6bgIJ8IlSWMMIOL4s7qevd77GRtLTz6EgC38EVjbp+ZHKJ5inX582MlxjD6WYcqGEYOnvCFGBpeFJnkAvhFIWxNyIx1tk1xxQgTHU8wMHjq/rMCl6USuZcSH4L1bzUMmgfZE='
    a = random.randint(1, modulus-1)
    e = 5
    k = e * d - 1
    while pow(a, k, modulus) == 1 and k % 2 == 0:
        k = k / 2
    r = pow(a, k, modulus)
    if pow(r, 2, modulus) == 1:
        xy = euclid_etc.extended_euclid(r-1, modulus)
        p = xy[0]
        q = modulus/p
        m = (p-1)*(q-1)
        d_new = modinv(3, m)
        decrypt_me = kthroot(3, d_new)
        ct_as_bits = b64_to_bits(ct)
        convert_me = pow(ct_as_bits, d_new, modulus)
        h = hex(convert_me)
        h = h[2:-1]
        answer = conversions.hex_to_as(h)
        print answer
        return answer
    else:
        problem3(ct, d, modulus)

def problem4(ct1_b64, ct2_b64, N1, N2):
# def problem4():
    # N1 = 87750187518907655534583445808737942078016029371855217057442341331127022016930461105786023716013285380470222803872626192434912740863485532564125627646878636545449869643527771922181597178447982975143657375859594541373428795038041796818858805812228886812351199020336314262507362189851970680226889619203804537151
    # N2 = 59077605606399909603607705484000546044333045357566473814158491087439387780574866766800852465743470772146755309189078604396507686696592563062056700875467732286553829707195406383141965288479916793429869646143662227281782900822010619445408818002981548245734527538573941174294649831309213962935858200869524073603
    # ct1_b64 = 'Ur/BIau7ZZBdwxD8P3xDJFJGMfkJDXNU5rbY7GlvlRkGae4NEMo3pMq9r8Jk2akGSj47SZ00L+eTmeMIIfis3RoG7jjBdj03p5lLtgrLwnjP0lzr31fasl5+NVZIvmnoEt56Figi54lIAXEj4ig06MHFG2KfotLYJTnwabangS4='
    # ct2_b64 = 'CPEXorDgegEqM6UttzFLaccAN/t4QB1FTDS+NL3TSofQlq3Rs/BebbNn4Qj/Vo4FmTwV3P0+n+hlIhjXzOgEgdgV3BmiBE3rIBHqUc+q0FoVvWJU1+jvFpEeellYZMX8vG7O9us5JKfDAHjPaHWZSwv++BSX4rh+5O01flxzlJA='
    xy = euclid_etc.extended_euclid(N1, N2)
    p = xy[0]
    q1 = N1/p
    q2 = N2/p
    m1 = (p-1)*(q1-1)
    m2 = (p-1)*(q2-1)
    d1 = modinv(65537, m1)
    d2 = modinv(65537, m2)
    ct1_as_bits = b64_to_bits(ct1_b64)
    ct2_as_bits = b64_to_bits(ct2_b64)
    pt1_as_bits = pow(ct1_as_bits, d1, N1)
    pt2_as_bits = pow(ct2_as_bits, d2, N2)
    h1 = hex(pt1_as_bits)
    h2 = hex(pt2_as_bits)
    h1 = h1[2:-1]
    h2 = h2[2:-1]
    answer1 = conversions.hex_to_as(h1)
    answer2 = conversions.hex_to_as(h2)
    print answer1
    print answer2
    return 'done'


def problem5(ctb64, N, e):
# def problem5():
    # e = 65537
    # N = 104267313539010410259697196441509577894896177181353222939098975044658256653731229369696658803005865075730776171497005390040729021346385892644721558032556950267328480157757202775565554421465561098972037171123794802541382258202303916754661689619425811225128735978214662249095628369305188282273814273882601469489
    # ctb64 = 'j/pGAvf886IqKc4IN6TNPTSymwReGjUxUjB7F7r2aEk9bIuZPuRezm3wGCYBifv7u7kDcLQ9k4f/i5luqD/oFGS8PaJljrftLmlpa6hlUm8S/dU8h1tFW884ddtAoGTfZbN5vN4hNcSBGWPQHNzghDgwzNw/4IrqjGL81DckUdY='
    i = 0
    j = 0
    ct_bits = b64_to_bits(ctb64)
    lookup_table = {}
    isSuccess = 0
    for i in range(1, 5000000):
        entry = pow(i, e, N)
        if entry not in lookup_table:
            lookup_table[entry] = i
        i += 1
    for j in range(1, 5000000):
        match = ct_bits * (modinv(pow(j, e, N), N)) % N
        if match in lookup_table:
            isSuccess += 1
            i = lookup_table[match]
            break
        j += 1
    if isSuccess != 1:
        return "Error: attack failed"
    else:
        h = hex(i * j)
        # h = h[2:-1]
        h = h[2:]
        answer = conversions.hex_to_as(h)
        return "plaintext is: " + answer


def problem6(p, g, gxmodp, x, alpha, beta):
# def problem6():
    # p = 191147927718986609689229466631454649812986246276667354864188503638807260703436799058776201365135161278134258296128109200046702912984568752800330221777752773957404540495707852046983
    # g = 5
    # x = 42694797205671621659845608467948077104282354898632405210027867058530843815065930986742716022222447350595400603633273172816767784236961837688169657044396569579700949515830214254992
    # alpha = 73982478796308483406582889587923018499575337266536017447507799702797406257043632101045569763590982806403627704785985032506296784648293661856246199184245278019913797261546316759270
    # beta = 1227561673735205443986782574414500194775280963876704725208507831364630528829422611287956320336912905023628854115065478249082243473610928313596901712034514819305660036543382454852
    # gxmodp = pow(g, x, p)
    k_shared = pow(alpha, x, p)
    message = (beta * modinv(k_shared, p)) % p
    h = hex(message)
    h = h[2:-1]
    answer = conversions.hex_to_as(h)
    return answer


def problem7(p, g, gxmodp, alpha, beta, m, beta2):
# def problem7():
#     p = 191147927718986609689229466631454649812986246276667354864188503638807260703436799058776201365135161278134258296128109200046702912984568752800330221777752773957404540495707852046983
#     g = 5
#     gx = 176478319826764259370406117740489882944142268114222243573886354279989450112247437716236796057251798300509450763347865746885560883563075519833320667906000345397226327059751213369961
#     alpha = 104862672745740711919811315922065122010281934991422240638097533405207971405689057652673577043484488015740722326384001808611695005135028713487234715202873484670021923322009761545457
#     beta = 17606878671981551311137298337848994393797765223509173646178261989274226953505667592410786573428076963287971811161509360601971410344413313700739795932040261074709506491861567699546
#     beta2 = 116115839773157782821329377087409766815814624668492668098672866213651171163182813304753241741593566110843721045751605192482170477996370202802973966889697676265503034822908949368607
#     m = "Now my charms are all o'erthrown and what strength I have's mine own."
    m_b64 = conversions.as_to_b64(m)
    m_bits = b64_to_bits(m_b64)
    k_shared = (beta * modinv(m_bits, p)) % p
    output_message =(beta2 * modinv(k_shared, p)) % p
    h = hex(output_message)
    h = h[2:-1]
    answer = conversions.hex_to_as(h)
    return answer


def problem8(p, g, gxmodp, alpha, beta, y):
# def problem8():
    secret_exp = 42694797205671621659845608467948077104282354898632405210027867058530843815065930986742716022222447350595400603633273172816767784236961837688169657044396569579700949515830214254992
    # p = 191147927718986609689229466631454649812986246276667354864188503638807260703436799058776201365135161278134258296128109200046702912984568752800330221777752773957404540495707852046983
    # g = 5
    # alpha = 104862672745740711919811315922065122010281934991422240638097533405207971405689057652673577043484488015740722326384001808611695005135028713487234715202873484670021923322009761545457
    # beta = 112018886720018236580229932176683955946063514397085867696250318378121351302079624330821244744748925197792097406122146093507280201522804485024833199924734248052247065779216659451112
    # y = 138670566126823584879625861326333326312363943825621039220215583346153783336272559955521970357301302912046310782908659450758549108092918331352215751346054755216673005939933186397777
    k_public = pow(g, secret_exp, p)
    k_shared = pow(k_public, y, p)
    output_message = (beta * modinv(k_shared, p)) % p
    h = hex(output_message)
    h = h[2:-1]
    answer = conversions.hex_to_as(h)
    return answer